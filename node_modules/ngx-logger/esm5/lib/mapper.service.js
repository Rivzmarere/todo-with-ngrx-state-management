/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
var NGXMapperService = /** @class */ (function () {
    function NGXMapperService(httpBackend) {
        this.httpBackend = httpBackend;
        // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
        this.sourceMapCache = new Map();
        // cache for specific log position, key is the dist position, ie 'main.js:339:21'
        this.logPositionCache = new Map();
    }
    /*
    Static Functions
   */
    /*
      Static Functions
     */
    /**
     * @private
     * @param {?} proxiedSteps
     * @return {?}
     */
    NGXMapperService.getStackLine = /*
      Static Functions
     */
    /**
     * @private
     * @param {?} proxiedSteps
     * @return {?}
     */
    function (proxiedSteps) {
        /** @type {?} */
        var error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                // Here are different examples of stacktrace 
                // Firefox (last line is the user code, the 4 first are ours):
                // getStackLine@http://localhost:4200/main.js:358:23
                // getCallerDetails@http://localhost:4200/main.js:557:44
                // _log@http://localhost:4200/main.js:830:28
                // debug@http://localhost:4200/main.js:652:14
                // handleLog@http://localhost:4200/main.js:1158:29
                // Chrome and Edge (last line is the user code):
                // Error
                // at Function.getStackLine (ngx-logger.js:329)
                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)
                // at NGXLogger._log (ngx-logger.js:801)
                // at NGXLogger.info (ngx-logger.js:631)
                // at AppComponent.handleLog (app.component.ts:38)
                /** @type {?} */
                var defaultProxy = 4;
                // We make 4 functions call before getting here
                /** @type {?} */
                var firstStackLine = error.stack.split('\n')[0];
                if (!firstStackLine.includes('.js:')) {
                    // The stacktrace starts with no function call (example in Chrome or Edge)
                    defaultProxy = defaultProxy + 1;
                }
                return error.stack.split('\n')[(defaultProxy + (proxiedSteps || 0))];
            }
            catch (e) {
                return null;
            }
        }
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getPosition = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        var positionStartIndex = stackLine.lastIndexOf('\/');
        /** @type {?} */
        var positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        /** @type {?} */
        var position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        /** @type {?} */
        var dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getTranspileLocation = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        // Example stackLine:
        // Firefox : getStackLine@http://localhost:4200/main.js:358:23
        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)
        /** @type {?} */
        var locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf('@');
            if (locationStartIndex < 0) {
                locationStartIndex = stackLine.lastIndexOf(' ');
            }
        }
        /** @type {?} */
        var locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getMapFilePath = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        /** @type {?} */
        var file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        var mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    };
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    NGXMapperService.getMapping = /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    function (sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        var sourceFileIndex = 0;
        /** @type {?} */
        var // second field
        sourceCodeLine = 0;
        /** @type {?} */
        var // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        var lines = sourceMap.mappings.split(';');
        for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            var generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            var columns = lines[lineIndex].split(',');
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                var decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * does the http get request to get the source map
     * @param sourceMapLocation
     * @param distPosition
     */
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    NGXMapperService.prototype._getSourceMap = /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    function (sourceMapLocation, distPosition) {
        /** @type {?} */
        var req = new HttpRequest('GET', sourceMapLocation);
        /** @type {?} */
        var distPositionKey = distPosition.toString();
        // if the specific log position is already in cache return it
        if (this.logPositionCache.has(distPositionKey)) {
            return this.logPositionCache.get(distPositionKey);
        }
        // otherwise check if the source map is already cached for given source map location
        if (!this.sourceMapCache.has(sourceMapLocation)) {
            // obtain the source map if not cached
            this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e instanceof HttpResponse; })), map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            function (httpResponse) { return httpResponse.body; })), retry(3), shareReplay(1)));
        }
        // at this point the source map is cached, use it to get specific log position mapping
        /** @type {?} */
        var logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((/**
         * @param {?} sourceMap
         * @return {?}
         */
        function (sourceMap) {
            // map generated position to source position
            return NGXMapperService.getMapping(sourceMap, distPosition);
        })), catchError((/**
         * @return {?}
         */
        function () { return of(distPosition); })), shareReplay(1));
        // store specific log position in cache for given dest position and return it
        this.logPositionCache.set(distPositionKey, logPosition$);
        return logPosition$;
    };
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param sourceMapsEnabled
     * @param proxiedSteps
     */
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @param {?} proxiedSteps
     * @return {?}
     */
    NGXMapperService.prototype.getCallerDetails = /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @param {?} proxiedSteps
     * @return {?}
     */
    function (sourceMapsEnabled, proxiedSteps) {
        // parse generated file mapping from stack trace
        var _this = this;
        // parse generated file mapping from stack trace
        /** @type {?} */
        var stackLine = NGXMapperService.getStackLine(proxiedSteps);
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = tslib_1.__read(_a, 2), distPosition = _b[0], sourceMapLocation = _b[1];
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return _this._getSourceMap(sourceMapLocation, distPosition);
        })));
    };
    NGXMapperService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NGXMapperService.ctorParameters = function () { return [
        { type: HttpBackend }
    ]; };
    return NGXMapperService;
}());
export { NGXMapperService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.sourceMapCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.logPositionCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5RSxPQUFPLEtBQUssR0FBRyxNQUFNLEtBQUssQ0FBQztBQUMzQixPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVuRDtJQVNFLDBCQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTs7UUFMcEMsbUJBQWMsR0FBdUMsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7UUFHL0QscUJBQWdCLEdBQXlDLElBQUksR0FBRyxFQUFFLENBQUM7SUFHM0UsQ0FBQztJQUVEOztLQUVDOzs7Ozs7Ozs7SUFDYyw2QkFBWTs7Ozs7Ozs7SUFBM0IsVUFBNEIsWUFBb0I7O1lBQ3hDLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRTtRQUV6QixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU0sS0FBSyxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUVWLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBa0JFLFlBQVksR0FBRyxDQUFDOzs7b0JBQ2QsY0FBYyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFR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R0osQ0FBQzs7Z0JBNU5GLFVBQVU7Ozs7Z0JBTkYsV0FBVzs7SUFtT3BCLHVCQUFDO0NBQUEsQUE3TkQsSUE2TkM7U0E1TlksZ0JBQWdCOzs7Ozs7SUFHM0IsMENBQXVFOzs7OztJQUd2RSw0Q0FBMkU7Ozs7O0lBRS9ELHVDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvdXJjZU1hcCB9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBIdHRwQmFja2VuZCwgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuaW1wb3J0ICogYXMgdmxxIGZyb20gJ3ZscSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGZpbHRlciwgbWFwLCByZXRyeSwgc2hhcmVSZXBsYXksIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgTG9nUG9zaXRpb24gfSBmcm9tICcuL3R5cGVzL2xvZy1wb3NpdGlvbic7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBOR1hNYXBwZXJTZXJ2aWNlIHtcclxuXHJcbiAgLy8gY2FjaGUgZm9yIHNvdXJjZSBtYXBzLCBrZXkgaXMgc291cmNlIG1hcCBsb2NhdGlvbiwgaWUuICdodHRwOi8vbG9jYWxob3N0OjQyMDAvbWFpbi5qcy5tYXAnXHJcbiAgcHJpdmF0ZSBzb3VyY2VNYXBDYWNoZTogTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxTb3VyY2VNYXA+PiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgLy8gY2FjaGUgZm9yIHNwZWNpZmljIGxvZyBwb3NpdGlvbiwga2V5IGlzIHRoZSBkaXN0IHBvc2l0aW9uLCBpZSAnbWFpbi5qczozMzk6MjEnXHJcbiAgcHJpdmF0ZSBsb2dQb3NpdGlvbkNhY2hlOiBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPj4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cEJhY2tlbmQ6IEh0dHBCYWNrZW5kKSB7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIFN0YXRpYyBGdW5jdGlvbnNcclxuICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhY2tMaW5lKHByb3hpZWRTdGVwczogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gbm9pbnNwZWN0aW9uIEV4Y2VwdGlvbkNhdWdodExvY2FsbHlKU1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gSGVyZSBhcmUgZGlmZmVyZW50IGV4YW1wbGVzIG9mIHN0YWNrdHJhY2UgXHJcblxyXG4gICAgICAgIC8vIEZpcmVmb3ggKGxhc3QgbGluZSBpcyB0aGUgdXNlciBjb2RlLCB0aGUgNCBmaXJzdCBhcmUgb3Vycyk6XHJcbiAgICAgICAgLy8gZ2V0U3RhY2tMaW5lQGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMC9tYWluLmpzOjM1ODoyM1xyXG4gICAgICAgIC8vIGdldENhbGxlckRldGFpbHNAaHR0cDovL2xvY2FsaG9zdDo0MjAwL21haW4uanM6NTU3OjQ0XHJcbiAgICAgICAgLy8gX2xvZ0BodHRwOi8vbG9jYWxob3N0OjQyMDAvbWFpbi5qczo4MzA6MjhcclxuICAgICAgICAvLyBkZWJ1Z0BodHRwOi8vbG9jYWxob3N0OjQyMDAvbWFpbi5qczo2NTI6MTRcclxuICAgICAgICAvLyBoYW5kbGVMb2dAaHR0cDovL2xvY2FsaG9zdDo0MjAwL21haW4uanM6MTE1ODoyOVxyXG5cclxuICAgICAgICAvLyBDaHJvbWUgYW5kIEVkZ2UgKGxhc3QgbGluZSBpcyB0aGUgdXNlciBjb2RlKTpcclxuICAgICAgICAvLyBFcnJvclxyXG4gICAgICAgIC8vIGF0IEZ1bmN0aW9uLmdldFN0YWNrTGluZSAobmd4LWxvZ2dlci5qczozMjkpXHJcbiAgICAgICAgLy8gYXQgTkdYTWFwcGVyU2VydmljZS5nZXRDYWxsZXJEZXRhaWxzIChuZ3gtbG9nZ2VyLmpzOjUyOClcclxuICAgICAgICAvLyBhdCBOR1hMb2dnZXIuX2xvZyAobmd4LWxvZ2dlci5qczo4MDEpXHJcbiAgICAgICAgLy8gYXQgTkdYTG9nZ2VyLmluZm8gKG5neC1sb2dnZXIuanM6NjMxKVxyXG4gICAgICAgIC8vIGF0IEFwcENvbXBvbmVudC5oYW5kbGVMb2cgKGFwcC5jb21wb25lbnQudHM6MzgpXHJcblxyXG4gICAgICAgIGxldCBkZWZhdWx0UHJveHkgPSA0OyAvLyBXZSBtYWtlIDQgZnVuY3Rpb25zIGNhbGwgYmVmb3JlIGdldHRpbmcgaGVyZVxyXG4gICAgICAgIGNvbnN0IGZpcnN0U3RhY2tMaW5lID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpWzBdO1xyXG4gICAgICAgIGlmICghZmlyc3RTdGFja0xpbmUuaW5jbHVkZXMoJy5qczonKSkge1xyXG4gICAgICAgICAgLy8gVGhlIHN0YWNrdHJhY2Ugc3RhcnRzIHdpdGggbm8gZnVuY3Rpb24gY2FsbCAoZXhhbXBsZSBpbiBDaHJvbWUgb3IgRWRnZSlcclxuICAgICAgICAgIGRlZmF1bHRQcm94eSA9IGRlZmF1bHRQcm94eSArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpWyhkZWZhdWx0UHJveHkgKyAocHJveGllZFN0ZXBzIHx8IDApKV07XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0UG9zaXRpb24oc3RhY2tMaW5lOiBzdHJpbmcpOiBMb2dQb3NpdGlvbiB7XHJcbiAgICAvLyBzdHJpcCBiYXNlIHBhdGgsIHRoZW4gcGFyc2UgZmlsZW5hbWUsIGxpbmUsIGFuZCBjb2x1bW5cclxuICAgIGNvbnN0IHBvc2l0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignXFwvJyk7XHJcbiAgICBsZXQgcG9zaXRpb25FbmRJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCcpJyk7XHJcbiAgICBpZiAocG9zaXRpb25FbmRJbmRleCA8IDApIHtcclxuICAgICAgcG9zaXRpb25FbmRJbmRleCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHN0YWNrTGluZS5zdWJzdHJpbmcocG9zaXRpb25TdGFydEluZGV4ICsgMSwgcG9zaXRpb25FbmRJbmRleCk7XHJcbiAgICBjb25zdCBkYXRhQXJyYXkgPSBwb3NpdGlvbi5zcGxpdCgnOicpO1xyXG4gICAgaWYgKGRhdGFBcnJheS5sZW5ndGggPT09IDMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihkYXRhQXJyYXlbMF0sICtkYXRhQXJyYXlbMV0sICtkYXRhQXJyYXlbMl0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbigndW5rbm93bicsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VHJhbnNwaWxlTG9jYXRpb24oc3RhY2tMaW5lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgLy8gRXhhbXBsZSBzdGFja0xpbmU6XHJcbiAgICAvLyBGaXJlZm94IDogZ2V0U3RhY2tMaW5lQGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMC9tYWluLmpzOjM1ODoyM1xyXG4gICAgLy8gQ2hyb21lIGFuZCBFZGdlIDogYXQgRnVuY3Rpb24uZ2V0U3RhY2tMaW5lIChuZ3gtbG9nZ2VyLmpzOjMyOSlcclxuICAgIGxldCBsb2NhdGlvblN0YXJ0SW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKCcpO1xyXG4gICAgaWYgKGxvY2F0aW9uU3RhcnRJbmRleCA8IDApIHtcclxuICAgICAgbG9jYXRpb25TdGFydEluZGV4ID0gc3RhY2tMaW5lLmxhc3RJbmRleE9mKCdAJyk7XHJcbiAgICAgIGlmIChsb2NhdGlvblN0YXJ0SW5kZXggPCAwKSB7XHJcbiAgICAgICAgbG9jYXRpb25TdGFydEluZGV4ID0gc3RhY2tMaW5lLmxhc3RJbmRleE9mKCcgJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgbG9jYXRpb25FbmRJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCcpJyk7XHJcbiAgICBpZiAobG9jYXRpb25FbmRJbmRleCA8IDApIHtcclxuICAgICAgbG9jYXRpb25FbmRJbmRleCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RhY2tMaW5lLnN1YnN0cmluZyhsb2NhdGlvblN0YXJ0SW5kZXggKyAxLCBsb2NhdGlvbkVuZEluZGV4KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGdldE1hcEZpbGVQYXRoKHN0YWNrTGluZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGZpbGUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFRyYW5zcGlsZUxvY2F0aW9uKHN0YWNrTGluZSk7XHJcbiAgICBjb25zdCBtYXBGdWxsUGF0aCA9IGZpbGUuc3Vic3RyaW5nKDAsIGZpbGUubGFzdEluZGV4T2YoJzonKSk7XHJcbiAgICByZXR1cm4gbWFwRnVsbFBhdGguc3Vic3RyaW5nKDAsIG1hcEZ1bGxQYXRoLmxhc3RJbmRleE9mKCc6JykpICsgJy5tYXAnO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWFwcGluZyhzb3VyY2VNYXA6IFNvdXJjZU1hcCwgcG9zaXRpb246IExvZ1Bvc2l0aW9uKTogTG9nUG9zaXRpb24ge1xyXG4gICAgLy8gPT4gJzsnIGluZGljYXRlcyBlbmQgb2YgYSBsaW5lXHJcbiAgICAvLyA9PiAnLCcgc2VwYXJhdGVzIG1hcHBpbmdzIGluIGEgbGluZVxyXG4gICAgLy8gZGVjb2RlZCBtYXBwaW5nID0+IFsgZ2VuZXJhdGVkQ29kZUNvbHVtbiwgc291cmNlRmlsZUluZGV4LCBzb3VyY2VDb2RlTGluZSwgc291cmNlQ29kZUNvbHVtbiwgbmFtZUluZGV4IF1cclxuICAgIGxldCBzb3VyY2VGaWxlSW5kZXggPSAwLCAgIC8vIHNlY29uZCBmaWVsZFxyXG4gICAgICBzb3VyY2VDb2RlTGluZSA9IDAsICAgIC8vIHRoaXJkIGZpZWxkXHJcbiAgICAgIHNvdXJjZUNvZGVDb2x1bW4gPSAwOyAgLy8gZm91cnRoIGZpZWxkXHJcblxyXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2VNYXAubWFwcGluZ3Muc3BsaXQoJzsnKTtcclxuXHJcbiAgICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCBsaW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XHJcbiAgICAgIC8vIHJlc2V0IGNvbHVtbiBwb3NpdGlvbiB0byAwIGFmdGVyIGVhY2ggbGluZVxyXG4gICAgICBsZXQgZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7XHJcbiAgICAgIC8vIGRlY29kZSBzZWN0aW9ucyBpbiBsaW5lXHJcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBsaW5lc1tsaW5lSW5kZXhdLnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1ucy5sZW5ndGg7IGNvbHVtbkluZGV4KyspIHtcclxuICAgICAgICBjb25zdCBkZWNvZGVkU2VjdGlvbiA9IHZscS5kZWNvZGUoY29sdW1uc1tjb2x1bW5JbmRleF0pO1xyXG4gICAgICAgIGlmIChkZWNvZGVkU2VjdGlvbi5sZW5ndGggPj0gNCkge1xyXG4gICAgICAgICAgLy8gdXBkYXRlIHJlbGF0aXZlIHBvc2l0aW9uc1xyXG4gICAgICAgICAgZ2VuZXJhdGVkQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblswXTtcclxuICAgICAgICAgIHNvdXJjZUZpbGVJbmRleCArPSBkZWNvZGVkU2VjdGlvblsxXTtcclxuICAgICAgICAgIHNvdXJjZUNvZGVMaW5lICs9IGRlY29kZWRTZWN0aW9uWzJdO1xyXG4gICAgICAgICAgc291cmNlQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGlmIG1hdGNoaW5nIG1hcFxyXG4gICAgICAgIGlmIChsaW5lSW5kZXggPT09IHBvc2l0aW9uLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgIGlmIChnZW5lcmF0ZWRDb2RlQ29sdW1uID09PSBwb3NpdGlvbi5jb2x1bW5OdW1iZXIpIHtcclxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgY29sdW1uIGFuZCBsaW5lIGZvdW5kXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oc291cmNlTWFwLnNvdXJjZXNbc291cmNlRmlsZUluZGV4XSwgc291cmNlQ29kZUxpbmUsIHNvdXJjZUNvZGVDb2x1bW4pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW5JbmRleCArIDEgPT09IGNvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBub3QgZm91bmQsIGJ1dCBsaW5lIGlzIGNvcnJlY3RcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihzb3VyY2VNYXAuc291cmNlc1tzb3VyY2VGaWxlSW5kZXhdLCBzb3VyY2VDb2RlTGluZSwgMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBmYWlsZWQgaWYgcmVhY2hlZFxyXG4gICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbigndW5rbm93bicsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZG9lcyB0aGUgaHR0cCBnZXQgcmVxdWVzdCB0byBnZXQgdGhlIHNvdXJjZSBtYXBcclxuICAgKiBAcGFyYW0gc291cmNlTWFwTG9jYXRpb25cclxuICAgKiBAcGFyYW0gZGlzdFBvc2l0aW9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0U291cmNlTWFwKHNvdXJjZU1hcExvY2F0aW9uOiBzdHJpbmcsIGRpc3RQb3NpdGlvbjogTG9nUG9zaXRpb24pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XHJcbiAgICBjb25zdCByZXEgPSBuZXcgSHR0cFJlcXVlc3Q8U291cmNlTWFwPignR0VUJywgc291cmNlTWFwTG9jYXRpb24pO1xyXG4gICAgY29uc3QgZGlzdFBvc2l0aW9uS2V5ID0gZGlzdFBvc2l0aW9uLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgLy8gaWYgdGhlIHNwZWNpZmljIGxvZyBwb3NpdGlvbiBpcyBhbHJlYWR5IGluIGNhY2hlIHJldHVybiBpdFxyXG4gICAgaWYgKHRoaXMubG9nUG9zaXRpb25DYWNoZS5oYXMoZGlzdFBvc2l0aW9uS2V5KSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2dQb3NpdGlvbkNhY2hlLmdldChkaXN0UG9zaXRpb25LZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG90aGVyd2lzZSBjaGVjayBpZiB0aGUgc291cmNlIG1hcCBpcyBhbHJlYWR5IGNhY2hlZCBmb3IgZ2l2ZW4gc291cmNlIG1hcCBsb2NhdGlvblxyXG4gICAgaWYgKCF0aGlzLnNvdXJjZU1hcENhY2hlLmhhcyhzb3VyY2VNYXBMb2NhdGlvbikpIHtcclxuICAgICAgLy8gb2J0YWluIHRoZSBzb3VyY2UgbWFwIGlmIG5vdCBjYWNoZWRcclxuICAgICAgdGhpcy5zb3VyY2VNYXBDYWNoZS5zZXQoXHJcbiAgICAgICAgc291cmNlTWFwTG9jYXRpb24sXHJcbiAgICAgICAgdGhpcy5odHRwQmFja2VuZC5oYW5kbGUocmVxKS5waXBlKFxyXG4gICAgICAgICAgZmlsdGVyKChlKSA9PiBlIGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSxcclxuICAgICAgICAgIG1hcDxIdHRwUmVzcG9uc2U8U291cmNlTWFwPiwgU291cmNlTWFwPihcclxuICAgICAgICAgICAgKGh0dHBSZXNwb25zZTogSHR0cFJlc3BvbnNlPFNvdXJjZU1hcD4pID0+IGh0dHBSZXNwb25zZS5ib2R5XHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgcmV0cnkoMyksXHJcbiAgICAgICAgICBzaGFyZVJlcGxheSgxKVxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBzb3VyY2UgbWFwIGlzIGNhY2hlZCwgdXNlIGl0IHRvIGdldCBzcGVjaWZpYyBsb2cgcG9zaXRpb24gbWFwcGluZ1xyXG4gICAgY29uc3QgbG9nUG9zaXRpb24kID0gdGhpcy5zb3VyY2VNYXBDYWNoZS5nZXQoc291cmNlTWFwTG9jYXRpb24pLnBpcGUoXHJcbiAgICAgIG1hcDxTb3VyY2VNYXAsIExvZ1Bvc2l0aW9uPigoc291cmNlTWFwKSA9PlxyXG4gICAgICAgIC8vIG1hcCBnZW5lcmF0ZWQgcG9zaXRpb24gdG8gc291cmNlIHBvc2l0aW9uXHJcbiAgICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRNYXBwaW5nKHNvdXJjZU1hcCwgZGlzdFBvc2l0aW9uKVxyXG4gICAgICApLFxyXG4gICAgICBjYXRjaEVycm9yKCgpID0+IG9mKGRpc3RQb3NpdGlvbikpLFxyXG4gICAgICBzaGFyZVJlcGxheSgxKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBzdG9yZSBzcGVjaWZpYyBsb2cgcG9zaXRpb24gaW4gY2FjaGUgZm9yIGdpdmVuIGRlc3QgcG9zaXRpb24gYW5kIHJldHVybiBpdFxyXG4gICAgdGhpcy5sb2dQb3NpdGlvbkNhY2hlLnNldChkaXN0UG9zaXRpb25LZXksIGxvZ1Bvc2l0aW9uJCk7XHJcblxyXG4gICAgcmV0dXJuIGxvZ1Bvc2l0aW9uJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIExvZ1Bvc2l0aW9uIGZvciB0aGUgY3VycmVudCBsb2dcclxuICAgKiBJZiBzb3VyY2VNYXBzIGFyZSBlbmFibGVkLCBpdCBhdHRlbXBzIHRvIGdldCB0aGUgc291cmNlIG1hcCBmcm9tIHRoZSBzZXJ2ZXIsIGFuZCB1c2UgdGhhdCB0byBwYXJzZSB0aGUgZmlsZSBuYW1lXHJcbiAgICogYW5kIG51bWJlciBvZiB0aGUgY2FsbFxyXG4gICAqIEBwYXJhbSBzb3VyY2VNYXBzRW5hYmxlZFxyXG4gICAqIEBwYXJhbSBwcm94aWVkU3RlcHNcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0Q2FsbGVyRGV0YWlscyhzb3VyY2VNYXBzRW5hYmxlZDogYm9vbGVhbiwgcHJveGllZFN0ZXBzOiBudW1iZXIpOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XHJcbiAgICAvLyBwYXJzZSBnZW5lcmF0ZWQgZmlsZSBtYXBwaW5nIGZyb20gc3RhY2sgdHJhY2VcclxuXHJcbiAgICBjb25zdCBzdGFja0xpbmUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFN0YWNrTGluZShwcm94aWVkU3RlcHMpO1xyXG5cclxuICAgIC8vIGlmIHdlIHdlcmUgbm90IGFibGUgdG8gcGFyc2UgdGhlIHN0YWNrTGluZSwganVzdCByZXR1cm4gYW4gZW1wdHkgTG9nIFBvc2l0aW9uXHJcbiAgICBpZiAoIXN0YWNrTGluZSkge1xyXG4gICAgICByZXR1cm4gb2YobmV3IExvZ1Bvc2l0aW9uKCcnLCAwLCAwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9mKFtcclxuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRQb3NpdGlvbihzdGFja0xpbmUpLFxyXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcEZpbGVQYXRoKHN0YWNrTGluZSlcclxuICAgIF0pLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcDxbTG9nUG9zaXRpb24sIHN0cmluZ10sIE9ic2VydmFibGU8TG9nUG9zaXRpb24+PigoW2Rpc3RQb3NpdGlvbiwgc291cmNlTWFwTG9jYXRpb25dKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIGlmIHNvdXJjZSBtYXBzIGFyZSBub3QgZW5hYmxlZCwgb3IgaWYgd2UndmUgcHJldmlvdXNseSB0cmllZCB0byBnZXQgdGhlIHNvdXJjZSBtYXBzLCBidXQgdGhleSBmYWlsZWQsXHJcbiAgICAgICAgLy8gdGhlbiBqdXN0IHVzZSB0aGUgcG9zaXRpb24gb2YgdGhlIEpTIGluc3RlYWQgb2YgdGhlIHNvdXJjZVxyXG4gICAgICAgIGlmICghc291cmNlTWFwc0VuYWJsZWQpIHtcclxuICAgICAgICAgIHJldHVybiBvZihkaXN0UG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmluYWxseSB0cnkgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwIGFuZCByZXR1cm4gdGhlIHBvc2l0aW9uXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbiwgZGlzdFBvc2l0aW9uKTtcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG5cclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbiJdfQ==