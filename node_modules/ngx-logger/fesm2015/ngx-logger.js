import { isPlatformBrowser, DatePipe, CommonModule } from '@angular/common';
import { Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';
import { HttpRequest, HttpResponse, HttpBackend, HttpHeaders, HttpParams } from '@angular/common/http';
import { filter, map, retry, shareReplay, catchError, switchMap } from 'rxjs/operators';
import { decode } from 'vlq';
import { of } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NGXLoggerHttpService {
    /**
     * @param {?} httpBackend
     */
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
    }
    /**
     * @param {?} url
     * @param {?} log
     * @param {?} options
     * @return {?}
     */
    logOnServer(url, log, options) {
        // HttpBackend skips all HttpInterceptors
        // They may log errors using this service causing circular calls
        /** @type {?} */
        const req = new HttpRequest('POST', url, log, options || {});
        return this.httpBackend.handle(req).pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        e => e instanceof HttpResponse)), map((/**
         * @param {?} httpResponse
         * @return {?}
         */
        (httpResponse) => httpResponse.body)));
    }
}
NGXLoggerHttpService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXLoggerHttpService.ctorParameters = () => [
    { type: HttpBackend }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NgxLoggerLevel = {
    TRACE: 0,
    DEBUG: 1,
    INFO: 2,
    LOG: 3,
    WARN: 4,
    ERROR: 5,
    FATAL: 6,
    OFF: 7,
};
NgxLoggerLevel[NgxLoggerLevel.TRACE] = 'TRACE';
NgxLoggerLevel[NgxLoggerLevel.DEBUG] = 'DEBUG';
NgxLoggerLevel[NgxLoggerLevel.INFO] = 'INFO';
NgxLoggerLevel[NgxLoggerLevel.LOG] = 'LOG';
NgxLoggerLevel[NgxLoggerLevel.WARN] = 'WARN';
NgxLoggerLevel[NgxLoggerLevel.ERROR] = 'ERROR';
NgxLoggerLevel[NgxLoggerLevel.FATAL] = 'FATAL';
NgxLoggerLevel[NgxLoggerLevel.OFF] = 'OFF';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoggerConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NGXLoggerConfigEngine {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this._config = config;
    }
    /**
     * Get a readonly access to the level configured for the NGXLogger
     * @return {?}
     */
    get level() {
        return this._config.level;
    }
    /**
     * Get a readonly access to the serverLogLevel configured for the NGXLogger
     * @return {?}
     */
    get serverLogLevel() {
        return this._config.serverLogLevel;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    updateConfig(config) {
        this._config = this._clone(config);
    }
    /**
     * @return {?}
     */
    getConfig() {
        return this._clone(this._config);
    }
    // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)
    // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make
    // this a deep clone
    /**
     * @private
     * @param {?} object
     * @return {?}
     */
    _clone(object) {
        /** @type {?} */
        const cloneConfig = new LoggerConfig();
        Object.keys(object).forEach((/**
         * @param {?} key
         * @return {?}
         */
        (key) => {
            cloneConfig[key] = object[key];
        }));
        return cloneConfig;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_COLOR_SCHEME = [
    'purple',
    'teal',
    'gray',
    'gray',
    'red',
    'red',
    'red'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NGXLoggerUtils {
    /**
     * @param {?} timestamp
     * @param {?} logLevel
     * @param {?} fileName
     * @param {?} lineNumber
     * @return {?}
     */
    static prepareMetaString(timestamp, logLevel, fileName, lineNumber) {
        /** @type {?} */
        const fileDetails = fileName ? ` [${fileName}:${lineNumber}]` : '';
        return `${timestamp} ${logLevel}${fileDetails}`;
    }
    /**
     * @param {?} level
     * @param {?=} configColorScheme
     * @return {?}
     */
    static getColor(level, configColorScheme) {
        switch (level) {
            case NgxLoggerLevel.TRACE:
                return this.getColorFromConfig(NgxLoggerLevel.TRACE, configColorScheme);
            case NgxLoggerLevel.DEBUG:
                return this.getColorFromConfig(NgxLoggerLevel.DEBUG, configColorScheme);
            case NgxLoggerLevel.INFO:
                return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);
            case NgxLoggerLevel.LOG:
                return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);
            case NgxLoggerLevel.WARN:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.ERROR:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.FATAL:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.OFF:
            default:
                return;
        }
    }
    /**
     * @private
     * @param {?} level
     * @param {?} configColorScheme
     * @return {?}
     */
    static getColorFromConfig(level, configColorScheme) {
        if (!configColorScheme) {
            return DEFAULT_COLOR_SCHEME[level];
        }
        return configColorScheme[level];
    }
    /**
     * @param {?} message
     * @return {?}
     */
    static prepareMessage(message) {
        try {
            if (typeof message !== 'string' && !(message instanceof Error)) {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (e) {
            // additional = [message, ...additional];
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    }
    /**
     * @param {?} additional
     * @return {?}
     */
    static prepareAdditionalParameters(additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map((/**
         * @param {?} next
         * @param {?} idx
         * @return {?}
         */
        (next, idx) => {
            try {
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                if (typeof next === 'object') {
                    JSON.stringify(next);
                }
                return next;
            }
            catch (e) {
                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LogPosition {
    /**
     * @param {?} fileName
     * @param {?} lineNumber
     * @param {?} columnNumber
     */
    constructor(fileName, lineNumber, columnNumber) {
        this.fileName = fileName;
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
    /**
     * @return {?}
     */
    toString() {
        return this.fileName + ':' + this.lineNumber + ':' + this.columnNumber;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NGXMapperService {
    /**
     * @param {?} httpBackend
     */
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
        // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
        this.sourceMapCache = new Map();
        // cache for specific log position, key is the dist position, ie 'main.js:339:21'
        this.logPositionCache = new Map();
    }
    /*
      Static Functions
     */
    /**
     * @private
     * @param {?} proxiedSteps
     * @return {?}
     */
    static getStackLine(proxiedSteps) {
        /** @type {?} */
        const error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                // Here are different examples of stacktrace 
                // Firefox (last line is the user code, the 4 first are ours):
                // getStackLine@http://localhost:4200/main.js:358:23
                // getCallerDetails@http://localhost:4200/main.js:557:44
                // _log@http://localhost:4200/main.js:830:28
                // debug@http://localhost:4200/main.js:652:14
                // handleLog@http://localhost:4200/main.js:1158:29
                // Chrome and Edge (last line is the user code):
                // Error
                // at Function.getStackLine (ngx-logger.js:329)
                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)
                // at NGXLogger._log (ngx-logger.js:801)
                // at NGXLogger.info (ngx-logger.js:631)
                // at AppComponent.handleLog (app.component.ts:38)
                /** @type {?} */
                let defaultProxy = 4;
                // We make 4 functions call before getting here
                /** @type {?} */
                const firstStackLine = error.stack.split('\n')[0];
                if (!firstStackLine.includes('.js:')) {
                    // The stacktrace starts with no function call (example in Chrome or Edge)
                    defaultProxy = defaultProxy + 1;
                }
                return error.stack.split('\n')[(defaultProxy + (proxiedSteps || 0))];
            }
            catch (e) {
                return null;
            }
        }
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getPosition(stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        const positionStartIndex = stackLine.lastIndexOf('\/');
        /** @type {?} */
        let positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        /** @type {?} */
        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        /** @type {?} */
        const dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getTranspileLocation(stackLine) {
        // Example stackLine:
        // Firefox : getStackLine@http://localhost:4200/main.js:358:23
        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)
        /** @type {?} */
        let locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf('@');
            if (locationStartIndex < 0) {
                locationStartIndex = stackLine.lastIndexOf(' ');
            }
        }
        /** @type {?} */
        let locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getMapFilePath(stackLine) {
        /** @type {?} */
        const file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        const mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    }
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    static getMapping(sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        let sourceFileIndex = 0;
        /** @type {?} */
        let // second field
        sourceCodeLine = 0;
        /** @type {?} */
        let // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        const lines = sourceMap.mappings.split(';');
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            let generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            const columns = lines[lineIndex].split(',');
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                const decodedSection = decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    _getSourceMap(sourceMapLocation, distPosition) {
        /** @type {?} */
        const req = new HttpRequest('GET', sourceMapLocation);
        /** @type {?} */
        const distPositionKey = distPosition.toString();
        // if the specific log position is already in cache return it
        if (this.logPositionCache.has(distPositionKey)) {
            return this.logPositionCache.get(distPositionKey);
        }
        // otherwise check if the source map is already cached for given source map location
        if (!this.sourceMapCache.has(sourceMapLocation)) {
            // obtain the source map if not cached
            this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            (e) => e instanceof HttpResponse)), map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            (httpResponse) => httpResponse.body)), retry(3), shareReplay(1)));
        }
        // at this point the source map is cached, use it to get specific log position mapping
        /** @type {?} */
        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((/**
         * @param {?} sourceMap
         * @return {?}
         */
        (sourceMap) => 
        // map generated position to source position
        NGXMapperService.getMapping(sourceMap, distPosition))), catchError((/**
         * @return {?}
         */
        () => of(distPosition))), shareReplay(1));
        // store specific log position in cache for given dest position and return it
        this.logPositionCache.set(distPositionKey, logPosition$);
        return logPosition$;
    }
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @param {?} proxiedSteps
     * @return {?}
     */
    getCallerDetails(sourceMapsEnabled, proxiedSteps) {
        // parse generated file mapping from stack trace
        // parse generated file mapping from stack trace
        /** @type {?} */
        const stackLine = NGXMapperService.getStackLine(proxiedSteps);
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([distPosition, sourceMapLocation]) => {
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return this._getSourceMap(sourceMapLocation, distPosition);
        })));
    }
}
NGXMapperService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXMapperService.ctorParameters = () => [
    { type: HttpBackend }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Levels = [
    'TRACE',
    'DEBUG',
    'INFO',
    'LOG',
    'WARN',
    'ERROR',
    'FATAL',
    'OFF'
];
class NGXLogger {
    /**
     * @param {?} mapperService
     * @param {?} httpService
     * @param {?} loggerConfig
     * @param {?} platformId
     * @param {?} datePipe
     */
    constructor(mapperService, httpService, loggerConfig, platformId, datePipe) {
        this.mapperService = mapperService;
        this.httpService = httpService;
        this.platformId = platformId;
        this.datePipe = datePipe;
        this._withCredentials = false;
        this._isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&
            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
        // each instance of the logger should have their own config engine
        this.config = new NGXLoggerConfigEngine(loggerConfig);
        this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);
    }
    /**
     * Get a readonly access to the level configured for the NGXLogger
     * @return {?}
     */
    get level() {
        return this.config.level;
    }
    /**
     * Get a readonly access to the serverLogLevel configured for the NGXLogger
     * @return {?}
     */
    get serverLogLevel() {
        return this.config.serverLogLevel;
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    trace(message, ...additional) {
        this._log(NgxLoggerLevel.TRACE, message, additional);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    debug(message, ...additional) {
        this._log(NgxLoggerLevel.DEBUG, message, additional);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    info(message, ...additional) {
        this._log(NgxLoggerLevel.INFO, message, additional);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    log(message, ...additional) {
        this._log(NgxLoggerLevel.LOG, message, additional);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    warn(message, ...additional) {
        this._log(NgxLoggerLevel.WARN, message, additional);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    error(message, ...additional) {
        this._log(NgxLoggerLevel.ERROR, message, additional);
    }
    /**
     * @param {?} message
     * @param {...?} additional
     * @return {?}
     */
    fatal(message, ...additional) {
        this._log(NgxLoggerLevel.FATAL, message, additional);
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    setCustomHttpHeaders(headers) {
        this._customHttpHeaders = headers;
    }
    /**
     * @param {?} params
     * @return {?}
     */
    setCustomParams(params) {
        this._customParams = params;
    }
    /**
     * @param {?} withCredentials
     * @return {?}
     */
    setWithCredentialsOptionValue(withCredentials) {
        this._withCredentials = withCredentials;
    }
    /**
     * @param {?} monitor
     * @return {?}
     */
    registerMonitor(monitor) {
        this._loggerMonitor = monitor;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    updateConfig(config) {
        this.config.updateConfig(config);
    }
    /**
     * @return {?}
     */
    getConfigSnapshot() {
        return this.config.getConfig();
    }
    /**
     * @private
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    _logIE(level, metaString, message, additional) {
        // Coloring doesn't work in IE
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn(`${metaString} `, message, ...additional);
                break;
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                console.error(`${metaString} `, message, ...additional);
                break;
            case NgxLoggerLevel.INFO:
                console.info(`${metaString} `, message, ...additional);
                break;
            default:
                console.log(`${metaString} `, message, ...additional);
        }
    }
    /**
     * @private
     * @param {?} level
     * @param {?} metaString
     * @param {?} message
     * @param {?} additional
     * @return {?}
     */
    _logModern(level, metaString, message, additional) {
        /** @type {?} */
        const configuredColors = this.getConfigSnapshot().colorScheme;
        /** @type {?} */
        const color = NGXLoggerUtils.getColor(level, configuredColors);
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                console.error(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            case NgxLoggerLevel.INFO:
                console.info(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of
            // the console.trace statement
            // case NgxLoggerLevel.TRACE:
            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);
            //   break;
            case NgxLoggerLevel.DEBUG:
                console.debug(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            default:
                console.log(`%c${metaString}`, `color:${color}`, message, ...additional);
        }
    }
    /**
     * @private
     * @param {?} level
     * @param {?} message
     * @param {?=} additional
     * @param {?=} logOnServer
     * @return {?}
     */
    _log(level, message, additional = [], logOnServer = true) {
        /** @type {?} */
        const config = this.config.getConfig();
        /** @type {?} */
        const isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;
        /** @type {?} */
        const isLogLevelEnabled = level >= config.level;
        if (!(message && (isLog2Server || isLogLevelEnabled))) {
            return;
        }
        /** @type {?} */
        const logLevelString = Levels[level];
        message = typeof message === 'function' ? message() : message;
        // only use validated parameters for HTTP requests
        /** @type {?} */
        const validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);
        /** @type {?} */
        const timestamp = config.timestampFormat ?
            this.datePipe.transform(new Date(), config.timestampFormat) :
            new Date().toISOString();
        this.mapperService.getCallerDetails(config.enableSourceMaps, config.proxiedSteps).subscribe((/**
         * @param {?} callerDetails
         * @return {?}
         */
        (callerDetails) => {
            /** @type {?} */
            const logObject = {
                // prepareMessage is needed to match NGXLogInterface
                // Even though I think message should be of type any (same as console.xxx signature)
                // I'm not doing this right now as this would be a breaking change
                message: NGXLoggerUtils.prepareMessage(message),
                additional: validatedAdditionalParameters,
                level: level,
                timestamp: timestamp,
                fileName: callerDetails.fileName,
                lineNumber: callerDetails.lineNumber.toString()
            };
            if (this._loggerMonitor && isLogLevelEnabled) {
                this._loggerMonitor.onLog(logObject);
            }
            if (isLog2Server) {
                // make sure the stack gets sent to the server (without altering the message for console logging)
                logObject.message = message instanceof Error ? message.stack : message;
                logObject.message = NGXLoggerUtils.prepareMessage(logObject.message);
                /** @type {?} */
                const headers = this._customHttpHeaders || new HttpHeaders();
                headers.set('Content-Type', 'application/json');
                /** @type {?} */
                const options = {
                    headers: headers,
                    params: this._customParams || new HttpParams(),
                    responseType: config.httpResponseType || 'json',
                    withCredentials: this._withCredentials
                };
                // Allow logging on server even if client log level is off
                this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                (res) => {
                    // I don't think we should do anything on success
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    this._log(NgxLoggerLevel.ERROR, `FAILED TO LOG ON SERVER: ${message}`, [error], false);
                }));
            }
            // if no message or the log level is less than the environ
            if (isLogLevelEnabled && !config.disableConsoleLogging) {
                /** @type {?} */
                const metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, config.disableFileDetails ? null : callerDetails.fileName, callerDetails.lineNumber.toString());
                return this._logFunc(level, metaString, message, additional);
            }
        }));
    }
}
NGXLogger.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXLogger.ctorParameters = () => [
    { type: NGXMapperService },
    { type: NGXLoggerHttpService },
    { type: LoggerConfig },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: DatePipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * CustomNGXLoggerService is designed to allow users to get a new instance of a logger
 */
class CustomNGXLoggerService {
    /**
     * @param {?} mapperService
     * @param {?} httpService
     * @param {?} platformId
     * @param {?} datePipe
     */
    constructor(mapperService, httpService, platformId, datePipe) {
        this.mapperService = mapperService;
        this.httpService = httpService;
        this.platformId = platformId;
        this.datePipe = datePipe;
    }
    /**
     * @param {?} config
     * @param {?=} httpService
     * @param {?=} logMonitor
     * @param {?=} mapperService
     * @return {?}
     */
    create(config, httpService, logMonitor, mapperService) {
        // you can inject your own httpService or use the default,
        /** @type {?} */
        const logger = new NGXLogger(mapperService || this.mapperService, httpService || this.httpService, config, this.platformId, this.datePipe);
        if (logMonitor) {
            logger.registerMonitor(logMonitor);
        }
        return logger;
    }
}
CustomNGXLoggerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CustomNGXLoggerService.ctorParameters = () => [
    { type: NGXMapperService },
    { type: NGXLoggerHttpService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: DatePipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoggerModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: LoggerModule,
            providers: [
                { provide: LoggerConfig, useValue: config || {} },
                NGXLogger,
                NGXLoggerHttpService,
                CustomNGXLoggerService,
                NGXMapperService
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: LoggerModule,
            providers: [
                NGXLogger,
                NGXLoggerHttpService,
                CustomNGXLoggerService,
                NGXMapperService
            ]
        };
    }
}
LoggerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                providers: [
                    NGXLogger,
                    NGXLoggerHttpService,
                    CustomNGXLoggerService,
                    NGXMapperService,
                    DatePipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class NGXLoggerMonitor {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NGXLogInterface {
}

export { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, Levels, LoggerConfig, LoggerModule, NGXLogInterface, NGXLogger, NGXLoggerHttpService, NGXLoggerMonitor, NGXLoggerUtils, NGXMapperService, NgxLoggerLevel };
//# sourceMappingURL=ngx-logger.js.map
