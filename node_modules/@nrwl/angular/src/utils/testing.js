"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMockContext = exports.getTestArchitect = exports.createLib = exports.createApp = exports.getLibConfig = exports.getAppConfig = exports.callRule = exports.runExternalSchematic = exports.runMigration = exports.runSchematic = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const testing_1 = require("@angular-devkit/schematics/testing");
const name_utils_1 = require("@nrwl/workspace/src/utils/name-utils");
const testing_2 = require("@nrwl/workspace/testing");
const testing_3 = require("@angular-devkit/architect/testing");
const core_1 = require("@angular-devkit/core");
const architect_1 = require("@angular-devkit/architect");
const testRunner = new testing_1.SchematicTestRunner('@nrwl/angular', path_1.join(__dirname, '../../collection.json'));
testRunner.registerCollection('@nrwl/jest', path_1.join(__dirname, '../../../jest/collection.json'));
testRunner.registerCollection('@nrwl/workspace', path_1.join(__dirname, '../../../workspace/collection.json'));
testRunner.registerCollection('@nrwl/cypress', path_1.join(__dirname, '../../../cypress/collection.json'));
testRunner.registerCollection('@nrwl/storybook', path_1.join(__dirname, '../../../storybook/collection.json'));
const migrationTestRunner = new testing_1.SchematicTestRunner('@nrwl/workspace', path_1.join(__dirname, '../../migrations.json'));
function runSchematic(schematicName, options, tree) {
    return testRunner.runSchematicAsync(schematicName, options, tree).toPromise();
}
exports.runSchematic = runSchematic;
function runMigration(schematicName, options, tree) {
    return migrationTestRunner
        .runSchematicAsync(schematicName, options, tree)
        .toPromise();
}
exports.runMigration = runMigration;
function runExternalSchematic(collectionName, schematicName, options, tree) {
    return testRunner
        .runExternalSchematicAsync(collectionName, schematicName, options, tree)
        .toPromise();
}
exports.runExternalSchematic = runExternalSchematic;
function callRule(rule, tree) {
    return testRunner.callRule(rule, tree).toPromise();
}
exports.callRule = callRule;
var appConfig; // configure built in createApp()
var libConfig;
function getAppConfig() {
    return appConfig;
}
exports.getAppConfig = getAppConfig;
function getLibConfig() {
    return libConfig;
}
exports.getLibConfig = getLibConfig;
function createApp(tree, appName, routing = true) {
    appName = name_utils_1.toFileName(appName);
    // save for getAppDir() lookup by external *.spec.ts tests
    appConfig = {
        appName,
        appModule: `/apps/${appName}/src/app/app.module.ts`,
    };
    tree.create(appConfig.appModule, `
     import { NgModule } from '@angular/core';
     import { BrowserModule } from '@angular/platform-browser';
     ${routing ? "import { RouterModule } from '@angular/router'" : ''};
     import { AppComponent } from './app.component';
     @NgModule({
       imports: [BrowserModule, ${routing ? 'RouterModule.forRoot([])' : ''}],
       declarations: [AppComponent],
       bootstrap: [AppComponent]
     })
     export class AppModule {}
  `);
    tree.create(`/apps/${appName}/src/main.ts`, `
    import { enableProdMode } from '@angular/core';
    import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

    import { AppModule } from './app/app.module';
    import { environment } from './environments/environment';

    if (environment.production) {
      enableProdMode();
    }

    platformBrowserDynamic()
      .bootstrapModule(AppModule)
      .catch(err => console.log(err));
  `);
    tree.create(`/apps/${appName}/tsconfig.app.json`, JSON.stringify({
        include: ['**/*.ts'],
    }));
    tree.create(`/apps/${appName}-e2e/tsconfig.e2e.json`, JSON.stringify({
        include: ['../**/*.ts'],
    }));
    tree.overwrite('/workspace.json', JSON.stringify({
        newProjectRoot: '',
        version: 1,
        projects: {
            [appName]: {
                root: `apps/${appName}`,
                sourceRoot: `apps/${appName}/src`,
                architect: {
                    build: {
                        options: {
                            main: `apps/${appName}/src/main.ts`,
                        },
                    },
                    serve: {
                        options: {},
                    },
                },
            },
        },
    }));
    return tree;
}
exports.createApp = createApp;
function createLib(tree, libName) {
    const { name, className, fileName, propertyName } = name_utils_1.names(libName);
    libConfig = {
        name,
        module: `/libs/${propertyName}/src/lib/${fileName}.module.ts`,
        barrel: `/libs/${propertyName}/src/index.ts`,
    };
    tree.create(libConfig.module, `
      import { NgModule } from '@angular/core';
      import { CommonModule } from '@angular/common';
      @NgModule({
        imports: [
          CommonModule
        ],
        providers: []
      })
      export class ${className}Module { }
  `);
    tree.create(libConfig.barrel, `
    export * from './lib/${fileName}.module';
  `);
    return tree;
}
exports.createLib = createLib;
function getTestArchitect() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const architectHost = new testing_3.TestingArchitectHost('/root', '/root');
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const architect = new architect_1.Architect(architectHost, registry);
        yield architectHost.addBuilderFromPackage(path_1.join(__dirname, '../..'));
        return [architect, architectHost];
    });
}
exports.getTestArchitect = getTestArchitect;
function getMockContext() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const [architect, architectHost] = yield getTestArchitect();
        const context = new testing_2.MockBuilderContext(architect, architectHost);
        yield context.addBuilderFromPackage(path_1.join(__dirname, '../..'));
        return context;
    });
}
exports.getMockContext = getMockContext;
//# sourceMappingURL=testing.js.map