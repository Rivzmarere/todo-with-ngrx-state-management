"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProject = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
const path = require("path");
const update_ng_package_1 = require("./update-ng-package");
// TODO - refactor this into separate rules with better names
function updateProject(options) {
    return schematics_1.chain([
        (host, _context) => {
            const libRoot = `${options.projectRoot}/src/lib/`;
            const serviceSpecPath = path.join(libRoot, `${options.name}.service.spec.ts`);
            const componentSpecPath = path.join(libRoot, `${options.name}.component.spec.ts`);
            host.delete(path.join(libRoot, `${options.name}.service.ts`));
            if (host.exists(serviceSpecPath)) {
                host.delete(serviceSpecPath);
            }
            host.delete(path.join(libRoot, `${options.name}.component.ts`));
            if (host.exists(componentSpecPath)) {
                host.delete(path.join(libRoot, `${options.name}.component.spec.ts`));
            }
            if (!options.publishable && !options.buildable) {
                host.delete(path.join(options.projectRoot, 'ng-package.json'));
                host.delete(path.join(options.projectRoot, 'package.json'));
                host.delete(path.join(options.projectRoot, 'tsconfig.lib.prod.json'));
            }
            host.delete(path.join(options.projectRoot, 'karma.conf.js'));
            host.delete(path.join(options.projectRoot, 'src/test.ts'));
            host.delete(path.join(options.projectRoot, 'tsconfig.spec.json'));
            host.delete(path.join(libRoot, `${options.name}.module.ts`));
            host.create(path.join(libRoot, `${options.fileName}.module.ts`), `
            import { NgModule } from '@angular/core';
            import { CommonModule } from '@angular/common';
            
            @NgModule({
              imports: [
                CommonModule
              ]
            })
            export class ${options.moduleName} { }
            `);
            if (options.unitTestRunner !== 'none' && options.addModuleSpec) {
                host.create(path.join(libRoot, `${options.fileName}.module.spec.ts`), `
        import { async, TestBed } from '@angular/core/testing';
        import { ${options.moduleName} } from './${options.fileName}.module';
        
        describe('${options.moduleName}', () => {
          beforeEach(async(() => {
            TestBed.configureTestingModule({
              imports: [ ${options.moduleName} ]
            })
            .compileComponents();
          }));
        
          // TODO: Add real tests here.
          //
          // NB: This particular test does not do anything useful. 
          //     It does NOT check for correct instantiation of the module.
          it('should have a module definition', () => {
            expect(${options.moduleName}).toBeDefined();
          });
        });
              `);
            }
            host.overwrite(`${options.projectRoot}/src/index.ts`, `
            export * from './lib/${options.fileName}.module';
            `);
            return host;
        },
        schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files/lib'), [
            schematics_1.template(Object.assign(Object.assign({}, options), { offsetFromRoot: workspace_1.offsetFromRoot(options.projectRoot) })),
            schematics_1.move(options.projectRoot),
        ]), schematics_1.MergeStrategy.Overwrite),
        (host) => {
            return workspace_1.updateJsonInTree(workspace_1.getWorkspacePath(host), (json) => {
                const project = json.projects[options.name];
                const fixedProject = workspace_1.replaceAppNameWithPath(project, options.name, options.projectRoot);
                fixedProject.schematics = fixedProject.schematics || {};
                if (options.style !== 'css') {
                    fixedProject.schematics = Object.assign(Object.assign({}, fixedProject.schematics), { '@schematics/angular:component': {
                            style: options.style,
                        } });
                }
                if (!options.publishable && !options.buildable) {
                    delete fixedProject.architect.build;
                }
                else {
                    // adjust the builder path to our custom one
                    fixedProject.architect.build.builder = '@nrwl/angular:package';
                }
                delete fixedProject.architect.test;
                if (options.linter === "tslint" /* TsLint */) {
                    fixedProject.architect.lint.options.tsConfig = fixedProject.architect.lint.options.tsConfig.filter((path) => path !==
                        core_1.join(core_1.normalize(options.projectRoot), 'tsconfig.spec.json'));
                    fixedProject.architect.lint.options.exclude.push('!' + core_1.join(core_1.normalize(options.projectRoot), '**/*'));
                }
                if (options.linter === "eslint" /* EsLint */) {
                    fixedProject.architect.lint.builder = '@nrwl/linter:eslint';
                    fixedProject.architect.lint.options.lintFilePatterns = [
                        `${options.projectRoot}/src/**/*.ts`,
                    ];
                    delete fixedProject.architect.lint.options.tsConfig;
                    delete fixedProject.architect.lint.options.exclude;
                    host.delete(`${options.projectRoot}/tslint.json`);
                }
                json.projects[options.name] = fixedProject;
                return json;
            });
        },
        workspace_1.updateJsonInTree(`${options.projectRoot}/tsconfig.lib.json`, (json) => {
            if (options.unitTestRunner === 'jest') {
                json.exclude = ['src/test-setup.ts', '**/*.spec.ts'];
            }
            else if (options.unitTestRunner === 'none') {
                json.exclude = [];
            }
            else {
                json.exclude = json.exclude || [];
            }
            return Object.assign(Object.assign({}, json), { extends: `./tsconfig.json`, compilerOptions: Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${workspace_1.offsetFromRoot(options.projectRoot)}dist/out-tsc` }) });
        }),
        options.linter === "tslint" /* TsLint */
            ? workspace_1.updateJsonInTree(`${options.projectRoot}/tslint.json`, (json) => {
                return Object.assign(Object.assign({}, json), { extends: `${workspace_1.offsetFromRoot(options.projectRoot)}tslint.json`, linterOptions: {
                        exclude: ['!**/*'],
                    } });
            })
            : schematics_1.noop(),
        workspace_1.updateJsonInTree(`/nx.json`, (json) => {
            return Object.assign(Object.assign({}, json), { projects: Object.assign(Object.assign({}, json.projects), { [options.name]: { tags: options.parsedTags } }) });
        }),
        (host) => {
            return update_ng_package_1.updateNgPackage(host, options);
        },
    ]);
}
exports.updateProject = updateProject;
//# sourceMappingURL=update-project.js.map